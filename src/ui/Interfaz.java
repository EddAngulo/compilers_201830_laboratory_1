/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ui;

import core.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;

/**
 *
 * @author juan
 */
public class Interfaz extends javax.swing.JFrame {

    /**
     * Creates new form Interfaz
     */
    
    public Interfaz() {
        initComponents();
        //Grid.setTableHeader(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        inputRegex = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        inputCad = new javax.swing.JTextField();
        jButton2 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        Output = new javax.swing.JTextArea();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        Grid = new javax.swing.JTable();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        GridDet = new javax.swing.JTable();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        GridOpt = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Ubuntu", 1, 18)); // NOI18N
        jLabel1.setText("Laboratorio 1 - Eduardo Angulo, Juan Gómez, Camila Lozano");

        jLabel2.setText("Inserte expresión regular");

        inputRegex.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inputRegexActionPerformed(evt);
            }
        });

        jButton1.setText("Correr");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel3.setText("Digite cadena a probar");

        inputCad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inputCadActionPerformed(evt);
            }
        });

        jButton2.setText("Probar");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        Output.setColumns(20);
        Output.setRows(5);
        jScrollPane1.setViewportView(Output);

        jLabel4.setFont(new java.awt.Font("Ubuntu", 1, 15)); // NOI18N
        jLabel4.setText("Resultados:");

        Grid.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        jScrollPane2.setViewportView(Grid);

        jLabel5.setFont(new java.awt.Font("Ubuntu", 1, 15)); // NOI18N
        jLabel5.setText("Transiciones AFN:");

        jLabel6.setFont(new java.awt.Font("Ubuntu", 1, 15)); // NOI18N
        jLabel6.setText("Transiciones AFD No Optimo:");

        GridDet.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        jScrollPane3.setViewportView(GridDet);

        jLabel7.setFont(new java.awt.Font("Ubuntu", 1, 15)); // NOI18N
        jLabel7.setText("Transiciones AFD Optimo:");

        GridOpt.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        jScrollPane4.setViewportView(GridOpt);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel1)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(6, 6, 6)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel2)
                                    .addComponent(jLabel3))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(inputRegex)
                                    .addComponent(inputCad))))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, 175, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 344, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel5)
                                    .addComponent(jLabel6)
                                    .addComponent(jLabel7))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(inputRegex, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1))
                .addGap(3, 3, 3)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(inputCad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 439, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 159, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 109, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void inputRegexActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inputRegexActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_inputRegexActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        initArrays();
        initSymbols();
        initDict();
        Output.setText(null);

        //BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //String regex = br.readLine();
        String regex = inputRegex.getText();
        Output.append("Expresion regular ingresada: "+regex+nl);
        detectAlphabet(regex);
        Output.append("Alfabeto: "+alphabet+nl+nl);
        Graph g = thompson(regex);
        graph2matrix(g);
//        for (Node node : g.getNodes()) {
//            System.out.println(node.toString());
//        }
        //Dibujar Tabla
        DefaultTableModel tm = (DefaultTableModel) Grid.getModel();
        tm.setColumnCount(alphabet.size()+2);
        tm.setRowCount(AFN.size());
        JTableHeader tableHeader = Grid.getTableHeader();
        TableColumnModel tableColumnModel = tableHeader.getColumnModel();
        TableColumn tableColumn;
        tableColumn = tableColumnModel.getColumn(0);
        tableColumn.setHeaderValue("");
        tableColumn = tableColumnModel.getColumn(1);
        tableColumn.setHeaderValue("€");
        for (int k=2; k < tm.getColumnCount(); k++){
            tableColumn = tableColumnModel.getColumn(k);
            tableColumn.setHeaderValue(alphabet.get(k-2));
        }
        tableHeader.repaint();
        
        for(int z=0; z<AFN.size(); z++){
            Grid.setValueAt("   "+z, z, 0);
            if(INITSTATE.get(0) == z){
                Grid.setValueAt("-> "+z, z, 0);
            }
            if(finalStateAFN == z){
                Grid.setValueAt(" * "+z, z, 0);
            }
            if(finalStateAFN == z && INITSTATE.get(0) == z){
                Grid.setValueAt("->*"+z, z, 0);
            }
        }
        
        for (int i = 0; i < AFN.size(); i++) {
            for (int j = 0; j < alphabet.size()+1; j++) {
                Grid.setValueAt(AFN.get(i).get(j), i, j+1);
                if(AFN.get(i).get(j).isEmpty()){
                    Grid.setValueAt("-", i, j+1);
                }
            }
        }
//        testAFN();
        subsetsMethod();
        /*
        Output.append("AFD No Optimo:"+nl);
        for (ArrayList<Integer> AFDNoOPt1 : AFDNoOpt) {
            Output.append(AFDNoOPt1+nl);
        }*/
        Output.append("Conjuntos:"+nl);
        int subs = 0;
        for (ArrayList<Integer> subset : subsets) {
            Output.append(dictMap.get(subs)+" = "+subset+nl);
            subs++;
        }
        //Output.append("\nEstados Significativos del AFN:"+nl);
        //Output.append(AFNSigStates()+nl);
        sigStatesMethod(AFDNoOptSigStates());
        //Output.append(nl);
        Output.append("\nEstados Significativos del AFD No Optimo"+nl);
        int sign = 0;
        for (ArrayList<Integer> signifState : signifStates) {
            Output.append("ES("+dictMap.get(sign)+") = "+signifState+nl);
            sign++;
        }
        Output.append("\nEstados Significativos Identificados del AFD No Optimo"+nl);
        for(int i=0; i < signifStatesIdentif.size(); i++){
            Output.append("ES("+dictMap.get(recognizedStatesAFD.get(i))+") = "+signifStatesIdentif.get(i)+nl);
        }
        
        /*
        Output.append("\nAFD Optimo:"+nl);
        for (ArrayList<Integer> AFDOPt1 : AFDOpt) {
            Output.append(AFDOPt1+nl);
        }
        Output.append("\nEstados reconocidos: "+nl);
        for(int r : recognizedStatesAFD){
            Output.append(dictMap.get(r)+nl);
        }*/
        initStateAFDNoOpt = getInitStateAFDNoOpt();
        initStateAFDOpt = getInitStateAFDOpt();
        finalStateAFDNoOpt = getFinalStateAFDNoOpt();
        finalStateAFDOpt = getFinalStateAFDOpt();
        /*
        Output.append("\nEstado final: "+nl);
        for(int fin: finalStateAFDOpt){
            Output.append(dictMap.get(fin)+nl);
        }*/
        
        Output.append(nl);
        //Output.append("-> : Estado inicial"+nl);
        //Output.append("* : Estado final"+nl);
        //BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        //Dibujar Tabla 2
        DefaultTableModel tm2 = (DefaultTableModel) GridDet.getModel();
        tm2.setColumnCount(alphabet.size()+1);
        tm2.setRowCount(AFDNoOpt.size());
        JTableHeader tableHeader2 = GridDet.getTableHeader();
        TableColumnModel tableColumnModel2 = tableHeader2.getColumnModel();
        TableColumn tableColumn2;
        tableColumn2 = tableColumnModel2.getColumn(0);
        tableColumn2.setHeaderValue("");
        for (int k=1; k < tm2.getColumnCount(); k++){
            tableColumn2 = tableColumnModel2.getColumn(k);
            tableColumn2.setHeaderValue(alphabet.get(k-1));
        }
        tableHeader2.repaint();
        
        for(int z=0; z<AFDNoOpt.size(); z++){
            GridDet.setValueAt("   "+dictMap.get(z), z, 0);
            if(initStateAFDNoOpt == z){
                GridDet.setValueAt("-> "+dictMap.get(z), z, 0);
            }
            if(finalStateAFDNoOpt.contains(z)){
                GridDet.setValueAt(" * "+dictMap.get(z), z, 0);
            }
            if(finalStateAFDNoOpt.contains(z) && initStateAFDNoOpt == z){
                GridDet.setValueAt("->*"+dictMap.get(z), z, 0);
            }
        }
        System.out.println(AFDNoOpt);
        for (int i = 0; i < AFDNoOpt.size(); i++) {
            for (int j = 0; j < alphabet.size(); j++) {
                //GridDet.setValueAt(AFDNoOpt.get(i).get(j), i, j+1);
                GridDet.setValueAt(dictMap.get(AFDNoOpt.get(i).get(j)), i, j+1);
            }
        }
        
        //Dibujar Tabla 3
        DefaultTableModel tm3 = (DefaultTableModel) GridOpt.getModel();
        tm3.setColumnCount(alphabet.size()+1);
        tm3.setRowCount(AFDOpt.size());
        JTableHeader tableHeader3 = GridOpt.getTableHeader();
        TableColumnModel tableColumnModel3 = tableHeader3.getColumnModel();
        TableColumn tableColumn3;
        tableColumn3 = tableColumnModel3.getColumn(0);
        tableColumn3.setHeaderValue("");
        for (int k=1; k < tm2.getColumnCount(); k++){
            tableColumn3 = tableColumnModel3.getColumn(k);
            tableColumn3.setHeaderValue(alphabet.get(k-1));
        }
        tableHeader3.repaint();
        int cont = 0;
        for(int z : recognizedStatesAFD){
            
            GridOpt.setValueAt("   "+dictMap.get(z), cont, 0);
            if(initStateAFDOpt == z){
                GridOpt.setValueAt("-> "+dictMap.get(z), cont, 0);
            }
            if(finalStateAFDOpt.contains(z)){
                GridOpt.setValueAt(" * "+dictMap.get(z), cont, 0);
            }
            if(finalStateAFDOpt.contains(z) && initStateAFDOpt == z){
                GridOpt.setValueAt("->*"+dictMap.get(z), cont, 0);
            }
            cont++;
        }
        System.out.println("final "+finalStateAFDOpt);
        for (int i = 0; i < AFDOpt.size(); i++) {
            for (int j = 0; j < alphabet.size(); j++) {
                //GridOpt.setValueAt(AFDOpt.get(i).get(j), i, j+1);
                GridOpt.setValueAt(dictMap.get(AFDOpt.get(i).get(j)), i, j+1);
            }
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        
        String cad = inputCad.getText();
        Output.append("\nProbando la cadena: "+cad+nl);
        Output.append("\nCon el AFD No Optimo: "+nl);
        //Output.append("Path: "+nl);
        ArrayList<ArrayList<Integer>> moveAFDNoOpt = getPathAFDNoOpt(cad);
        ArrayList<Integer> pathAFDNoOpt = moveAFDNoOpt.get(0);
        ArrayList<Integer> transAFDNoOpt = moveAFDNoOpt.get(1);
        //Output.append(pathAFDNoOpt+nl);
        //Output.append(transAFDNoOpt+nl+nl);
        Output.append("La cadena: "+recognize(pathAFDNoOpt, finalStateAFDNoOpt, getTrigAFDNoOpt(cad))+nl);
        Output.append("Recorrido de reconocimiento o No reconocimiento:"+nl);
        moving(pathAFDNoOpt, transAFDNoOpt);
        Output.append("\nCon el AFD Optimo: "+nl);
        //Output.append("Path: "+nl);
        ArrayList<ArrayList<Integer>> moveAFDOpt = getPathAFDOpt(cad);
        ArrayList<Integer> pathAFDOpt = moveAFDOpt.get(0);
        ArrayList<Integer> transAFDOpt = moveAFDOpt.get(1);
        //Output.append(pathAFDOpt+nl);
        //Output.append(transAFDOpt+nl+nl);
        Output.append("La cadena: "+recognize(pathAFDOpt, finalStateAFDOpt, getTrigAFDOpt(cad))+nl);
        Output.append("Recorrido de reconocimiento o No reconocimiento:"+nl);
        moving(pathAFDOpt, transAFDOpt);
    }//GEN-LAST:event_jButton2ActionPerformed

    private void inputCadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inputCadActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_inputCadActionPerformed

    /**
     * @param args the command line arguments
     */
    
    public static String nl = "\n";
    
    public static final int EPS = -1;    
    public static final ArrayList<String> SPECIALSYMBOLS = new ArrayList<>();
    public static final ArrayList<String> PREDSYMBOLS = new ArrayList<>();
    public static final ArrayList<Integer> INITSTATE = new ArrayList<>();
    
    public static int finalStateAFN;
    public static int initStateAFDNoOpt;
    public static int initStateAFDOpt;
    public static ArrayList<Integer> finalStateAFDNoOpt;
    public static ArrayList<Integer> finalStateAFDOpt;
    
    static ArrayList<String> alphabet = new ArrayList<>();
    static ArrayList<ArrayList<Integer>> subsets = new ArrayList<>();
    static ArrayList<ArrayList<Integer>> signifStates = new ArrayList<>();
    static ArrayList<ArrayList<Integer>> signifStatesIdentif = new ArrayList<>();
    static ArrayList<ArrayList<Integer>> subsetsAFD = new ArrayList<>();
    static ArrayList<Integer> recognizedStatesAFD = new ArrayList<>();
    
    static ArrayList<ArrayList<ArrayList<Integer>>> AFN = new ArrayList<>();
    static ArrayList<ArrayList<Integer>> AFDNoOpt = new ArrayList<>();
    static ArrayList<ArrayList<Integer>> AFDOpt = new ArrayList<>();
    
    //Dictionary
    static Map<Integer, String> dictMap = new HashMap<Integer, String>();
    
    
    public static void main(String args[]) throws IOException {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Interfaz().setVisible(true);
            }
        });
        
        
    }
    private static void initArrays(){
        /*
        ArrayList<String> SPECIALSYMBOLS = new ArrayList<>();
        ArrayList<String> PREDSYMBOLS = new ArrayList<>();
        ArrayList<Integer> INITSTATE = new ArrayList<>();
        */
        dictMap.clear();
        alphabet.clear();
        subsets.clear();
        signifStates.clear();
        signifStatesIdentif.clear();
        subsetsAFD.clear();
        recognizedStatesAFD.clear();
        AFN.clear();
        AFDNoOpt.clear();
        AFDOpt.clear();
    }
    
    //Inicializar simbolos especiales
    private static void initSymbols(){
        SPECIALSYMBOLS.add("|");
        SPECIALSYMBOLS.add("?");
        SPECIALSYMBOLS.add("+");
        SPECIALSYMBOLS.add("*");
        PREDSYMBOLS.add("(");
        PREDSYMBOLS.add(")");
        INITSTATE.add(0);
        
    }
    
    private static void initDict(){
        dictMap.put(-1, "-");
        dictMap.put(0, "A");
        dictMap.put(1, "B");
        dictMap.put(2, "C");
        dictMap.put(3, "D");
        dictMap.put(4, "E");
        dictMap.put(5, "F");
        dictMap.put(6, "G");
        dictMap.put(7, "H");
        dictMap.put(8, "I");
        dictMap.put(9, "J");
        dictMap.put(10, "K");
        dictMap.put(11, "L");
        dictMap.put(12, "M");
        dictMap.put(13, "N");
        dictMap.put(14, "O");
        dictMap.put(15, "P");
        
    }
    
    //Detectar Alfabeto
    public static void detectAlphabet(String s){
        for (int i = 0; i < s.length(); i++) {
            String symb = "" + s.charAt(i);
            if(!SPECIALSYMBOLS.contains(symb) && !PREDSYMBOLS.contains(symb) && !alphabet.contains(symb)){
                alphabet.add(symb);
            }
        }
        Collections.sort(alphabet);
    }
    
    
    public static Graph thompson(String s){
        Graph g = new Graph();
        int i = 0;
        while(i < s.length()-1){
            String symb = "" + s.charAt(i);
            if(alphabet.contains(symb)){
                String next = "" + s.charAt(i+1);
                if(alphabet.contains(next)){
                    g = concatGraph(g, basicGraph(symb));
                }else if(SPECIALSYMBOLS.contains(next)){
                    switch(next){
                        case "*": {
                            g = concatGraph(g, kleeneGraph(basicGraph(symb)));
                            break;
                        }
                        case "+": {
                            g = concatGraph(g, positGraph(basicGraph(symb)));
                            break;
                        }
                        case "?": {
                            g = concatGraph(g, existGraph(basicGraph(symb)));
                            break;
                        }
                        case "|": {
                            g = concatGraph(g, basicGraph(symb));
                            while(i < s.length()-1 && ("" + s.charAt(i+1)).equals("|")){
                                i++;
                                String aux = "";
                                while(i < s.length()-1){
                                    next = "" + s.charAt(i+1);
                                    aux += next;
                                    i++;
                                }
                                System.out.println(aux);
                                Graph auxG = thompson(aux);
                                g = orGraph(g, auxG);
                            }
                            break;
                        }
                    }
                }else{
                    g = concatGraph(g, basicGraph(symb));
                }
            }else{
                if(symb.equals("(")){
                    String next = "" + s.charAt(i+1);
                    String aux = "";
                    int cont = 1;
                    while(!next.equals(")") || cont != 1){
                        aux += next;
                        if(next.equals("(")){
                            cont++;
                        }
                        if(next.equals(")")){
                            cont--;
                        }
                        i++;
                        next = "" + s.charAt(i+1);
                    }
                    System.out.println(aux);
                    Graph auxG = thompson(aux);
                    i++;
                    if(i < s.length()-1){
                        next = "" + s.charAt(i+1);
                    }else{
                        next = "";
                    }
                    if(alphabet.contains(next)){
                        g = concatGraph(g, auxG);
                    }else if(SPECIALSYMBOLS.contains(next)){
                        switch(next){
                            case "*": {
                                String nextAux;
                                if(i < s.length()-2){
                                    nextAux = "" + s.charAt(i+2);
                                }else{
                                    nextAux = "";
                                }
                                if(nextAux.equals("|")){
                                    i += 2;
                                    aux = "";
                                    while(i < s.length()-1){
                                        next = "" + s.charAt(i+1);
                                        aux += next;
                                        i++;
                                    }
                                    System.out.println(aux);
                                    Graph auxG2 = thompson(aux);
                                    g = concatGraph(g, orGraph(kleeneGraph(auxG), auxG2));
                                }else{
                                    g = concatGraph(g, kleeneGraph(auxG));
                                }
                                break;
                            }
                            case "+": {
                                String nextAux;
                                if(i < s.length()-2){
                                    nextAux = "" + s.charAt(i+2);
                                }else{
                                    nextAux = "";
                                }
                                if(nextAux.equals("|")){
                                    i += 2;
                                    aux = "";
                                    while(i < s.length()-1){
                                        next = "" + s.charAt(i+1);
                                        aux += next;
                                        i++;
                                    }
                                    System.out.println(aux);
                                    Graph auxG2 = thompson(aux);
                                    g = concatGraph(g, orGraph(positGraph(auxG), auxG2));
                                }else{
                                    g = concatGraph(g, positGraph(auxG));
                                }
                                break;
                            }
                            case "?": {
                                String nextAux;
                                if(i < s.length()-2){
                                    nextAux = "" + s.charAt(i+2);
                                }else{
                                    nextAux = "";
                                }
                                if(nextAux.equals("|")){
                                    i += 2;
                                    aux = "";
                                    while(i < s.length()-1){
                                        next = "" + s.charAt(i+1);
                                        aux += next;
                                        i++;
                                    }
                                    System.out.println(aux);
                                    Graph auxG2 = thompson(aux);
                                    g = concatGraph(g, orGraph(existGraph(auxG), auxG2));
                                }else{
                                    g = concatGraph(g, existGraph(auxG));
                                }
                                break;
                            }
                            case "|": {
                                i++;
                                aux = "";
                                while(i < s.length()-1){
                                    next = "" + s.charAt(i+1);
                                    aux += next;
                                    i++;
                                }
                                System.out.println(aux);
                                Graph auxG2 = thompson(aux);
                                g = concatGraph(g, orGraph(auxG, auxG2));
                                break;
                            }
                        }
                    }else{
                        g = concatGraph(g, auxG);
                    }
                }
            }
            i++;
        }
        String symb = "" + s.charAt(s.length()-1);
        if(alphabet.contains(symb) && i < s.length()){
            g = concatGraph(g, basicGraph(symb));
        }
        return g;
    }
    
    //Convertir Grafo de Thompson en Matriz de Transicion
    public static void graph2matrix(Graph g){
        for (int i = 0; i < g.getNodes().size(); i++) {
            AFN.add(new ArrayList<>());
            for (int j = 0; j < alphabet.size()+1; j++) {
                AFN.get(i).add(new ArrayList<>());
            }
            Node aux = g.getNodes().get(i);
            if(aux.getNode1() != null){
                AFN.get(i).get(aux.getNode1().getTrans()).add(aux.getNode1().getNode());
            }
            if(aux.getNode2() != null){
                AFN.get(i).get(aux.getNode2().getTrans()).add(aux.getNode2().getNode());
            }
        }
        finalStateAFN = g.getNodes().get(g.getNodes().size()-1).getNumber();
    }
    
    //Cerradura Epsilon
    public static ArrayList<Integer> cerrEPS(ArrayList<Integer> state){
        ArrayList<Integer> cerr = new ArrayList<>();
        ArrayList<Boolean> taken = new ArrayList<>();
        for (Integer state1 : state) {
            cerr.add(state1);
            taken.add(false);
        }
        int i = 0;
        while(!allTaken(taken)){
            int index = cerr.get(i);
            taken.set(i, true);
            ArrayList<Integer> epsTrans = AFN.get(index).get(0);
            for (Integer epsTran : epsTrans) {
                if(!cerr.contains(epsTran)){
                    cerr.add(epsTran);
                    taken.add(false);
                }
            }
            i++;
        }
        Collections.sort(cerr);
        return cerr;
    }
    
    //Mueve(S,a)
    public static ArrayList<Integer> move(ArrayList<Integer> state, int symb){
        ArrayList<Integer> move = new ArrayList<>();
        for (Integer state1 : state) {
            ArrayList<Integer> trans = AFN.get(state1).get(symb);
            for (Integer tran : trans) {
                if(!move.contains(tran)){
                    move.add(tran);
                }
            }
        }
        Collections.sort(move);
        return move;
    }
    
    //Todos tomados
    public static boolean allTaken(ArrayList<Boolean> taken){
        for (int i = 0; i < taken.size(); i++) {
            if(!taken.get(i)){
                return false;
            }
        }
        return true;
    }
    
    //Metodo de Subconjuntos
    public static void subsetsMethod(){
        ArrayList<Boolean> taken = new ArrayList<>();
        subsets.add(cerrEPS(INITSTATE));
        AFDNoOpt.add(new ArrayList<>());
        taken.add(false);
        int i = 0;
        while(!allTaken(taken)){
            for (int j = 1; j <= alphabet.size(); j++) {
                ArrayList<Integer> state = cerrEPS(move(subsets.get(i), j));
                if(!state.isEmpty()){
                    if(!subsets.contains(state)){
                        subsets.add(state);
                        taken.add(false);
                        AFDNoOpt.add(new ArrayList<>());
                    }
                    AFDNoOpt.get(i).add(subsets.indexOf(state));
                }else{
                    AFDNoOpt.get(i).add(EPS);
                }
            }
            taken.set(i, true);
            i++;
        }
    }
    
    //Estados Significativos del AFN
    public static ArrayList<Integer> AFNSigStates(){
        ArrayList<Integer> sigStates = new ArrayList<>();
        for (int i = 0; i < AFN.size(); i++) {
            if(AFN.get(i).get(0).isEmpty()){
                sigStates.add(i);
            }
        }
        Collections.sort(sigStates);
        return sigStates;
    }
    
    //Estados Significativos del AFD No Optimo
    public static ArrayList<ArrayList<Integer>> AFDNoOptSigStates(){
        ArrayList<Integer> AFNSigStates = AFNSigStates();
        
        ArrayList<ArrayList<Integer>> replaceWith = new ArrayList<>();
        ArrayList<Integer> repl = new ArrayList<>();
        ArrayList<Integer> with = new ArrayList<>();
        for (int i = 0; i < subsets.size(); i++) {
            ArrayList<Integer> sig = intersection(subsets.get(i), AFNSigStates);
            signifStates.add(sig);
            if(!signifStatesIdentif.contains(sig)){
                signifStatesIdentif.add(sig);
            }else{
                repl.add(i);
                with.add(signifStates.indexOf(sig));
            }
        }
        replaceWith.add(repl);
        replaceWith.add(with);
        System.out.println("repl: " + repl);
        System.out.println("with: " + with);
        return replaceWith;
    }
    
    //Interseccion de Conjuntos
    public static ArrayList<Integer> intersection(ArrayList<Integer> c1, ArrayList<Integer> c2){
        ArrayList<Integer> inter = new ArrayList<>();
        for (Integer c11 : c1) {
            if(c2.contains(c11)){
                inter.add(c11);
            }
        }
        Collections.sort(inter);
        return inter;
    }
    
    //Metodo de Estados Significativos
    public static void sigStatesMethod(ArrayList<ArrayList<Integer>> replaceWith){
        ArrayList<Integer> repl = replaceWith.get(0);
        ArrayList<Integer> with = replaceWith.get(1);
        for (int i = 0; i < AFDNoOpt.size(); i++) {
            if(!repl.contains(i)){
                ArrayList<Integer> aux = new ArrayList<>();
                for (Integer get : AFDNoOpt.get(i)) {
                    aux.add(get);
                }
                AFDOpt.add(aux);
                subsetsAFD.add(subsets.get(i));
                recognizedStatesAFD.add(i);
            }
        }
        for (int i = 0; i < AFDOpt.size(); i++) {
            for (int j = 0; j < AFDOpt.get(i).size(); j++) {
                for (int k = 0; k < repl.size(); k++) {
                    if(AFDOpt.get(i).get(j) == (int) repl.get(k)){
                        AFDOpt.get(i).set(j, with.get(k));
                    }
                }
            }
        }
    }
    
    //Obtener el Estado Inicial del AFD No Optimo
    public static int getInitStateAFDNoOpt(){
        int initS = 0;
        for (int i = 0; i < subsets.size(); i++) {
            if(subsets.get(i).contains(INITSTATE.get(0))){
               initS = i;
            }
        }
        return initS;
    }
    
    //Obtener el Estado Inicial del AFD Optimo
    public static int getInitStateAFDOpt(){
        int initS = 0;
        for (int i = 0; i < subsetsAFD.size(); i++) {
            if(subsetsAFD.get(i).contains(INITSTATE.get(0))){
               initS = recognizedStatesAFD.get(i);
            }
        }
        return initS;
    }
    
    //Obtener el(los) Estado(s) Final(es) del AFD No Optimo
    public static ArrayList<Integer> getFinalStateAFDNoOpt(){
        ArrayList<Integer> finalS = new ArrayList<>();
        for (int i = 0; i < subsets.size(); i++) {
            if(subsets.get(i).contains(finalStateAFN)){
               finalS.add(i); 
            }
        }
        return finalS;
    }
    
    //Obtener el(los) Estado(s) Final(es) del AFD Optimo
    public static ArrayList<Integer> getFinalStateAFDOpt(){
        ArrayList<Integer> finalS = new ArrayList<>();
        for (int i = 0; i < subsetsAFD.size(); i++) {
            if(subsetsAFD.get(i).contains(finalStateAFN)){
               finalS.add(recognizedStatesAFD.get(i)); 
            }
        }
        return finalS;
    }
    
    //Obtener el Camino de Reconocimiento para el AFD No Optimo
    public static ArrayList<ArrayList<Integer>> getPathAFDNoOpt(String cad){
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        ArrayList<Integer> path = new ArrayList<>();
        ArrayList<Integer> trans = new ArrayList<>();
        boolean stop = false;
        int i = 0;
        int actState = initStateAFDNoOpt;
        path.add(actState);
        while(i < cad.length() && !stop){
            String char1 = "" + cad.charAt(i);
            int index = alphabet.indexOf(char1);
            if(AFDNoOpt.get(actState).get(index) == EPS){
                stop = true;
                trans.add(index);
            }else{
                actState = AFDNoOpt.get(actState).get(index);
                path.add(actState);
                trans.add(index);
            }
            i++;
        }
        ans.add(path);
        ans.add(trans);
        return ans;
    }
    
    //Obtener el Camino de Reconocimiento para el AFD Optimo
    public static ArrayList<ArrayList<Integer>> getPathAFDOpt(String cad){
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        ArrayList<Integer> path = new ArrayList<>();
        ArrayList<Integer> trans = new ArrayList<>();
        boolean stop = false;
        int i = 0;
        int actState = initStateAFDOpt;
        path.add(actState);
        while(i < cad.length() && !stop){
            String char1 = "" + cad.charAt(i);
            int index = alphabet.indexOf(char1);
            if(AFDOpt.get(actState).get(index) == EPS){
                stop = true;
                trans.add(index);
            }else{
                actState = recognizedStatesAFD.indexOf(AFDOpt.get(actState).get(index));
                path.add(recognizedStatesAFD.get(actState));
                trans.add(index);
            }
            i++;
        }
        ans.add(path);
        ans.add(trans);
        return ans;
    }
    
    //Reconoce o No Reconoce
    
    public static String recognize(ArrayList<Integer> path, ArrayList<Integer> finalStates, boolean sw){
        if(!sw && finalStates.contains(path.get(path.size()-1))){
            return "Pertenece";
        }else{
            return "No Pertenece";
        }
    }
    
    //AFN de prueba
    private static void testAFN(){
        alphabet.add("a");
        alphabet.add("b");
        for (int i = 0; i <= 10; i++) {
            AFN.add(new ArrayList<>());
            for (int j = 0; j < 3; j++) {
                AFN.get(i).add(new ArrayList<>());
            }
        }
        AFN.get(0).get(0).add(1);
        AFN.get(0).get(0).add(7);
        
        AFN.get(1).get(0).add(2);
        AFN.get(1).get(0).add(4);
        
        AFN.get(2).get(1).add(3);
        
        AFN.get(3).get(0).add(6);
        
        AFN.get(4).get(2).add(5);
        
        AFN.get(5).get(0).add(6);
        
        AFN.get(6).get(0).add(1);
        AFN.get(6).get(0).add(7);
        
        AFN.get(7).get(1).add(8);
        
        AFN.get(8).get(2).add(9);
        
        AFN.get(9).get(2).add(10);
        
        finalStateAFN = 10;
    }
    
    //AFN de Prueba 2
    private static void testAFN2(){
        alphabet.add("a");
        alphabet.add("b");
        for (int i = 0; i <= 10; i++) {
            AFN.add(new ArrayList<>());
            for (int j = 0; j < 3; j++) {
                AFN.get(i).add(new ArrayList<>());
            }
        }
        AFN.get(0).get(1).add(1);
        
        AFN.get(1).get(0).add(2);
        AFN.get(1).get(0).add(8);
        
        AFN.get(2).get(0).add(3);
        AFN.get(2).get(0).add(5);
        
        AFN.get(3).get(1).add(4);
        
        AFN.get(4).get(0).add(7);
        
        AFN.get(5).get(2).add(6);
        
        AFN.get(6).get(0).add(7);
        
        AFN.get(7).get(0).add(2);
        AFN.get(7).get(0).add(8);
        
        AFN.get(8).get(2).add(9);
        
        AFN.get(9).get(2).add(10);
        
        finalStateAFN = 10;
    }
    
    //Grafo Basico AFN
    public static Graph basicGraph(String a){
        Graph g = new Graph();
        Node n1 = new Node(0);
        Node n2 = new Node(1);
        n1.setNode1(new Pair(n2.getNumber(), alphabet.indexOf(a) + 1));
        g.nodes.add(n1);
        g.nodes.add(n2);
        return g;
    }
    
    //Concatenacion de AFNs
    public static Graph concatGraph(Graph g1, Graph g2){
        Graph g = new Graph();
        if(g1.getNodes().isEmpty()){
            g1.getNodes().add(new Node(0));
        }
        for (Node node : g1.getNodes()) {
            g.getNodes().add(node);
        }
        if(!g2.getNodes().isEmpty()){
            if(g2.getNodes().get(0).getNode1() != null){
                g.getNodes().get(g.getNodes().size() - 1).setNode1(new Pair(g2.getNodes().get(0).getNode1().getNode() + g1.getNodes().size() - 1, g2.getNodes().get(0).getNode1().getTrans()));
            }
            if(g2.getNodes().get(0).getNode2() != null){
                g.getNodes().get(g.getNodes().size() - 1).setNode2(new Pair(g2.getNodes().get(0).getNode2().getNode() + g1.getNodes().size() - 1, g2.getNodes().get(0).getNode2().getTrans()));
            }
        }
        for (int i = 1; i < g2.getNodes().size(); i++) {
            Node aux = new Node(i + g1.getNodes().size() - 1);
            if(g2.getNodes().get(i).getNode1() != null){
                aux.setNode1(new Pair(g2.getNodes().get(i).getNode1().getNode() + g1.getNodes().size() - 1, g2.getNodes().get(i).getNode1().getTrans()));
            }
            if(g2.getNodes().get(i).getNode2() != null){
                aux.setNode2(new Pair(g2.getNodes().get(i).getNode2().getNode() + g1.getNodes().size() - 1, g2.getNodes().get(i).getNode2().getTrans()));
            }
            g.getNodes().add(aux);
        }
        return g;
    }
    
    //Or AFNs
    public static Graph orGraph(Graph g1, Graph g2){
        Graph g = new Graph();
        Node n0 = new Node(0);
        Node nf = new Node(g1.getNodes().size() + g2.getNodes().size() + 1);
        n0.setNode1(new Pair(g1.getNodes().get(0).getNumber() + 1, 0));
        n0.setNode2(new Pair(g2.getNodes().get(0).getNumber() + g1.getNodes().size() + 1, 0));
        g.getNodes().add(n0);
        for (int i = 0; i < g1.getNodes().size(); i++) {
            Node aux = new Node(i+1);
            if(g1.getNodes().get(i).getNode1() != null){
                aux.setNode1(new Pair(g1.getNodes().get(i).getNode1().getNode() + 1, g1.getNodes().get(i).getNode1().getTrans()));
            }
            if(g1.getNodes().get(i).getNode2() != null){
                aux.setNode2(new Pair(g1.getNodes().get(i).getNode2().getNode() + 1, g1.getNodes().get(i).getNode2().getTrans()));
            }
            g.getNodes().add(aux);
        }
        g.getNodes().get(g.getNodes().size() - 1).setNode1(new Pair(nf.getNumber(), 0));
        for (int i = 0; i < g2.getNodes().size(); i++) {
            Node aux = new Node(i + g1.getNodes().size() + 1);
            if(g2.getNodes().get(i).getNode1() != null){
                aux.setNode1(new Pair(g2.getNodes().get(i).getNode1().getNode() + g1.getNodes().size() + 1, g2.getNodes().get(i).getNode1().getTrans()));
            }
            if(g2.getNodes().get(i).getNode2() != null){
                aux.setNode2(new Pair(g2.getNodes().get(i).getNode2().getNode() + g1.getNodes().size() + 1, g2.getNodes().get(i).getNode2().getTrans()));
            }
            g.getNodes().add(aux);
        }
        g.getNodes().get(g.getNodes().size() - 1).setNode1(new Pair(nf.getNumber(), 0));
        g.getNodes().add(nf);
        return g;
    }
    
    //Cerradura de Kleene AFN
    public static Graph kleeneGraph(Graph g1){
        Graph g = new Graph();
        Node n0 = new Node(0);
        Node nf = new Node(g1.getNodes().size() + 1);
        n0.setNode1(new Pair(g1.getNodes().get(0).getNumber() + 1, 0));
        n0.setNode2(new Pair(nf.getNumber(), 0));
        g.getNodes().add(n0);
        for (int i = 0; i < g1.getNodes().size(); i++) {
            Node aux = new Node(i+1);
            if(g1.getNodes().get(i).getNode1() != null){
                aux.setNode1(new Pair(g1.getNodes().get(i).getNode1().getNode() + 1, g1.getNodes().get(i).getNode1().getTrans()));
            }
            if(g1.getNodes().get(i).getNode2() != null){
                aux.setNode2(new Pair(g1.getNodes().get(i).getNode2().getNode() + 1, g1.getNodes().get(i).getNode2().getTrans()));
            }
            g.getNodes().add(aux);
        }
        g.getNodes().get(g.getNodes().size() - 1).setNode1(new Pair(g.getNodes().get(1).getNumber(), 0));
        g.getNodes().get(g.getNodes().size() - 1).setNode2(new Pair(nf.getNumber(), 0));
        g.getNodes().add(nf);
        return g;
    }
    
    //Esta o No Esta AFN (?)
    public static Graph existGraph(Graph g1){
        Graph g = new Graph();
        Node n0 = new Node(0);
        Node nf = new Node(g1.getNodes().size() + 1);
        n0.setNode1(new Pair(g1.getNodes().get(0).getNumber() + 1, 0));
        n0.setNode2(new Pair(nf.getNumber(), 0));
        g.getNodes().add(n0);
        for (int i = 0; i < g1.getNodes().size(); i++) {
            Node aux = new Node(i+1);
            if(g1.getNodes().get(i).getNode1() != null){
                aux.setNode1(new Pair(g1.getNodes().get(i).getNode1().getNode() + 1, g1.getNodes().get(i).getNode1().getTrans()));
            }
            if(g1.getNodes().get(i).getNode2() != null){
                aux.setNode2(new Pair(g1.getNodes().get(i).getNode2().getNode() + 1, g1.getNodes().get(i).getNode2().getTrans()));
            }
            g.getNodes().add(aux);
        }
        g.getNodes().get(g.getNodes().size() - 1).setNode1(new Pair(nf.getNumber(), 0));
        g.getNodes().add(nf);
        return g;
    }
    
    //Cerradura Positiva AFN
    public static Graph positGraph(Graph g1){
        Graph g = new Graph();
        Node n0 = new Node(0);
        Node nf = new Node(g1.getNodes().size() + 1);
        n0.setNode1(new Pair(g1.getNodes().get(0).getNumber() + 1, 0));
        g.getNodes().add(n0);
        for (int i = 0; i < g1.getNodes().size(); i++) {
            Node aux = new Node(i+1);
            if(g1.getNodes().get(i).getNode1() != null){
                aux.setNode1(new Pair(g1.getNodes().get(i).getNode1().getNode() + 1, g1.getNodes().get(i).getNode1().getTrans()));
            }
            if(g1.getNodes().get(i).getNode2() != null){
                aux.setNode2(new Pair(g1.getNodes().get(i).getNode2().getNode() + 1, g1.getNodes().get(i).getNode2().getTrans()));
            }
            g.getNodes().add(aux);
        }
        g.getNodes().get(g.getNodes().size() - 1).setNode1(new Pair(g.getNodes().get(1).getNumber(), 0));
        g.getNodes().get(g.getNodes().size() - 1).setNode2(new Pair(nf.getNumber(), 0));
        g.getNodes().add(nf);
        return g;
    }
    
    public static boolean getTrigAFDNoOpt(String cad){
        ArrayList<Integer> path = new ArrayList<>();
        boolean stop = false;
        int i = 0;
        int actState = initStateAFDNoOpt;
        path.add(actState);
        while(i < cad.length() && !stop){
            String char1 = "" + cad.charAt(i);
            int index = alphabet.indexOf(char1);
            if(AFDNoOpt.get(actState).get(index) == EPS){
                stop = true;
            }else{
                actState = AFDNoOpt.get(actState).get(index);
                path.add(actState);
            }
            i++;
        }
        return stop;
    }
    
    public static boolean getTrigAFDOpt(String cad){
        ArrayList<Integer> path = new ArrayList<>();
        boolean stop = false;
        int i = 0;
        int actState = initStateAFDOpt;
        path.add(actState);
        while(i < cad.length() && !stop){
            String char1 = "" + cad.charAt(i);
            int index = alphabet.indexOf(char1);
            if(AFDOpt.get(actState).get(index) == EPS){
                stop = true;
            }else{
                actState = recognizedStatesAFD.indexOf(AFDOpt.get(actState).get(index));
                path.add(recognizedStatesAFD.get(actState));
            }
            i++;
        }
        return stop;
    }
    
    public void moving(ArrayList<Integer> path, ArrayList<Integer> trans){
        if(trans.size() != path.size()){
            for (int i = 0; i < trans.size(); i++) {
                Output.append("    mueve(" + dictMap.get(path.get(i)) + ", " + alphabet.get(trans.get(i)) + ") = " + dictMap.get(path.get(i+1))+nl);
            }
        }else{
            for (int i = 0; i < trans.size() - 1; i++) {
                Output.append("    mueve(" + dictMap.get(path.get(i)) + ", " + alphabet.get(trans.get(i)) + ") = " + dictMap.get(path.get(i+1))+nl);
            }
            Output.append("    mueve(" + dictMap.get(path.get(trans.size() - 1)) + ", " + alphabet.get(trans.get(trans.size() - 1)) + ") = €"+nl);
        }
    }
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable Grid;
    private javax.swing.JTable GridDet;
    private javax.swing.JTable GridOpt;
    private javax.swing.JTextArea Output;
    private javax.swing.JTextField inputCad;
    private javax.swing.JTextField inputRegex;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    // End of variables declaration//GEN-END:variables
}
